undefined + 1
NaN
// Тому що undefined не є число.

'true' == true
false
// Тому що для порівняння відбувається перетворення ʼtrue’ в число - видає NaN, NaN - false.

false == 'false'
false
// логічне значення false перетворюється в число - 0, строка ʼfalse’ в число - NaN. NaN повертає false.

null == ' '
false
// null == тільки undefined, воно не перетворюється ні в число, ні в строку.

3 ** (9 / 3);
27
// Тому що першим робиться операція в дужках, потім виведення у степінь.

!!'false' == !!'true'
true
// Подвійне заперечення перетворює на булеве логічне значення, так як люба не пуста строка означає true, оператор порівнює true i true.

0 || '0' && 1
1
// З врахування пріоритету «&&» операція (ʼ0ʼ && 1) = 1 - Видає останнє істинне значення. Потім (0 || 1 )= 1. Тому що видає перше істинне значення.

1 < 2 < 3
true
// Тому що (1 < 2) це true, потім true перетворюється на число - 1. (1 < 3) - true.

'foo'+ + +'bar'
'fooNaN'
// + перетворює на число строку ʼbar’ - виходить NaN. Інший плюс викликає конкретизацію.

3 ** 2 / 3;
3
// За пріоритетом взводимо (3 у ступінь 2) = 9, потім (9 / 3) = 3.

1 < 2 > 3
false
// Тому що (1 < 2) це true, true - це 1. Потім результат (1 > 3) це false.

(+null == false) < 1;
false
// Оператор + переводить null в число 0. (0 == false) - це true, тому що false при не строгому порівнянні переводить в 0. Далі порівнюється (true < 1), true переводиться в число 1. Далі (1 < 1), так як це не правда, то виходить false.

false && true || true
true
// Тому що (false && true) - false, видає перше хибне значення. (false || true) - true,  тому що останнє значення правдиве.

false && (true || true);
false
// Пріоритет у дужках результат буде true, далі (false && true) - буде false.

(+null == false) < 1 ** 5;
false
// Пріоритет у дужках. +null переводить в 0. Далі при не строгому порівнянні (0 == false) false переводить в 0. (0 == 0) це true. Далі за пріоритетом взводимо (1 в ступінь 5) = 1. Далі (true < 1). true переводиться в 1, залишається вираз (1 < 1) = false.